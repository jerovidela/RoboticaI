% --- EJERCICIO FINAL FARO SCANARM ---
clear; clc; close all;

%% --- 0. Cargar Robot y Parámetros ---
try
    robot; % Ejecuta tu archivo robot.m para crear el objeto R
    fprintf('Robot "%s" cargado correctamente.\n', R.name);
catch ME
    error('No se pudo cargar robot.m: %s', ME.message);
end

% Añadir Robotics Toolbox al path (si no está ya)
% Cambia la ruta si es necesario
% addpath(genpath('C:/ruta/a/rvctools'));

%% --- 1. Definir Puntos Cartesianos y Articulares Clave ---

% --- Puntos Articulares (q) ---
% !! IMPORTANTE: Reemplaza estos valores con los exactos de tus imágenes !!
% Valores aproximados basados en las imágenes proporcionadas
q_start = deg2rad([0, 0, -54.4, 3.8, -55.2, 0]);     % Imagen 1: Posición inicial
q_approach = deg2rad([0, 0, -3.8, -26.4, 0, 0]);     % Imagen 2: Posicionamiento (cerca)

% --- Parámetros de la Tarea ---
delta_z = 0.001; % Distancia vertical para simular contacto (1 mm)
delta_x = 0.05;  % Distancia de medición en X (5 cm)
t_seg1 = 4.0;    % Duración acercamiento (s)
t_seg2 = 5.0;    % Duración medición (s)
t_seg3 = 4.0;    % Duración retorno (s)
t_touch = 0.5;   % Duración corta para contacto/retracción (s)
dt = 0.05;       % Paso de tiempo para discretización (s)

% --- Calcular Matrices de Transformación Homogénea (T) ---
T_start = R.fkine(q_start);
T_approach = R.fkine(q_approach);

% Calcular Orientación del Palpador (45 grados)
% Rotación de -45 grados alrededor del eje Y global (para inclinar el eje Z de la herramienta)
R_palpador = roty(-45 * pi/180);
% Mantener la orientación X original del approach (o definir una específica si es necesario)
% Aquí usamos la orientación original de T_approach pero reemplazamos su Z con el inclinado
T_orient_temp = T_approach.T; % Obtener la matriz 4x4
R_approach_original = T_orient_temp(1:3, 1:3);
% Creamos la nueva matriz de rotación manteniendo X y ajustando Y, Z
x_vec_orig = R_approach_original(:,1); % Guardamos X original como referencia
y_vec_orig = R_approach_original(:,2); % Guardamos Y original como referencia

% 1. Definir el nuevo eje Z (inclinado 45 grados) - Eje principal
z_vec_nuevo = R_palpador * [0; 0; 1];
z_vec_nuevo = z_vec_nuevo / norm(z_vec_nuevo); % Asegurar que sea unitario

% 2. Definir el nuevo eje Y (intentar mantenerlo parecido al original, pero ortogonal a Z)
% Proyectamos el Y original sobre el plano normal a z_vec_nuevo
y_vec_temp = y_vec_orig - dot(y_vec_orig, z_vec_nuevo) * z_vec_nuevo;
y_vec_nuevo = y_vec_temp / norm(y_vec_temp); % Normalizar

% 3. Calcular el nuevo eje X usando producto cruz (X = Y x Z para mano derecha)
x_vec_nuevo = cross(y_vec_nuevo, z_vec_nuevo);
x_vec_nuevo = x_vec_nuevo / norm(x_vec_nuevo); % Asegurar que sea unitario

% 4. Construir la matriz final (asegurarse del orden correcto de columnas)
R_palpador_final = [x_vec_nuevo, y_vec_nuevo, z_vec_nuevo];
% Verificar si es una matriz de rotación válida
if abs(det(R_palpador_final) - 1) > 1e-5
    error('R_palpador_final no es una matriz de rotación válida.');
end
disp('Matriz de Orientación del Palpador (45 deg):');
disp(R_palpador_final);

% Actualizar T_approach con la orientación correcta
T_approach = rt2tr(R_palpador_final, T_approach.t);

% Calcular Poses de Contacto, Fin y Retracción
vec_z_tool = T_approach(1:3, 3);   % Eje Z de la herramienta (3ra columna de la parte de rotación)

T_contact_start_pos = T_approach(1:3, 4) - delta_z * vec_z_tool;
T_contact_start = rt2tr(R_palpador_final, T_contact_start_pos);

T_contact_end_pos = T_contact_start_pos + [delta_x; 0; 0]; % Mover 5cm en X global
T_contact_end = rt2tr(R_palpador_final, T_contact_end_pos);

T_retract_pos = T_contact_end_pos + delta_z * vec_z_tool; % Mover hacia arriba en dirección Z de la herramienta
T_retract = rt2tr(R_palpador_final, T_retract_pos);

% Calcular Puntos Articulares (q) faltantes usando Cinemática Inversa
try
    q_contact_start = cin_inv_Faro(R, T_contact_start, q_approach, true);
    q_contact_end = cin_inv_Faro(R, T_contact_end, q_contact_start, true);
    q_retract = cin_inv_Faro(R, T_retract, q_contact_end, true);
catch ME
    error('Falló la cinemática inversa: %s. \nAsegúrate que las poses son alcanzables y cin_inv_Faro funciona.', ME.message);
end

% --- Vectores de Tiempo y Pasos ---
N1 = round(t_seg1 / dt);
N_touch = round(t_touch / dt);
N2 = round(t_seg2 / dt);
N3 = round(t_seg3 / dt);
t1 = linspace(0, t_seg1, N1);
t_touch_vec = linspace(0, t_touch, N_touch);
t2 = linspace(0, t_seg2, N2);
t3 = linspace(0, t_seg3, N3);

% Tiempo total para gráficas
t_total = [t1, t1(end)+t_touch_vec(2:end), t1(end)+t_touch+t2(2:end), t1(end)+t_touch+t2(end)+t_touch_vec(2:end), t1(end)+t_touch+t2(end)+t_touch+t3(2:end)];

fprintf('--- Puntos Articulares Calculados ---\n');
fprintf('q_start:         %s\n', mat2str(rad2deg(q_start), 3));
fprintf('q_approach:      %s\n', mat2str(rad2deg(q_approach), 3));
fprintf('q_contact_start: %s\n', mat2str(rad2deg(q_contact_start'), 3)); % Transponer si cin_inv devuelve columna
fprintf('q_contact_end:   %s\n', mat2str(rad2deg(q_contact_end'), 3)); % Transponer si cin_inv devuelve columna
fprintf('q_retract:       %s\n', mat2str(rad2deg(q_retract'), 3));     % Transponer si cin_inv devuelve columna

%% --- 2. Implementación A: Interpolación Articular (jtraj) ---
fprintf('\n--- Calculando Método A (Todo jtraj) ---\n');
% Transponer (.') los resultados de cin_inv_Faro para asegurar que sean FILAS (1x6)
q_contact_start_fila = q_contact_start.'; % Transponer
q_contact_end_fila   = q_contact_end.';   % Transponer
q_retract_fila       = q_retract.';       % Transponer

[qA1, qdA1, qddA1] = jtraj(q_start, q_approach, N1);
[qA2, qdA2, qddA2] = jtraj(q_approach, q_contact_start_fila, N_touch); % Usar fila
[qA3, qdA3, qddA3] = jtraj(q_contact_start_fila, q_contact_end_fila, N2);   % Usar filas
[qA4, qdA4, qddA4] = jtraj(q_contact_end_fila, q_retract_fila, N_touch);     % Usar filas
[qA5, qdA5, qddA5] = jtraj(q_retract_fila, q_start, N3);                 % Usar filas

% Concatenar (quitando puntos repetidos entre segmentos)
qA = [qA1; qA2(2:end,:); qA3(2:end,:); qA4(2:end,:); qA5(2:end,:)];
qdA = [qdA1; qdA2(2:end,:); qdA3(2:end,:); qdA4(2:end,:); qdA5(2:end,:)];
qddA = [qddA1; qddA2(2:end,:); qddA3(2:end,:); qddA4(2:end,:); qddA5(2:end,:)];

% Calcular trayectoria cartesiana resultante
total_puntos_A = size(qA, 1);
posA = zeros(total_puntos_A, 3);
for i = 1:total_puntos_A
    T_curr = R.fkine(qA(i,:));
    posA(i,:) = T_curr.t';
end
velA = derivada(posA, t_total'); % Necesita t_total como columna
accA = derivada(velA, t_total');

%% --- 3. Implementación B: Interpolación Mixta (jtraj + ctraj) ---
%fprintf('--- Calculando Método B (Mixto jtraj/ctraj) ---\n');
% Segmento 1: jtraj (Start -> Approach)
%[qB1, qdB1, qddB1] = jtraj(q_start, q_approach, N1);
% Segmento 2: jtraj (Approach -> ContactStart)
%[qB2, qdB2, qddB2] = jtraj(q_approach, q_contact_start.', N_touch); % Asegurar fila

% Segmento 3: ctraj (ContactStart -> ContactEnd) - Medición
%T_segmento3 = ctraj(T_contact_start, T_contact_end, N2);
%qB3 = zeros(N2, R.n);
%q_seed_B = q_contact_start.'; % Semilla inicial es el final del segmento anterior
%{for i = 1:N2
   %% try
       %% q_sol = cin_inv_Faro(R, T_segmento3(:,:,i), q_seed_B, true);
       %% if ~isempty(q_sol) && ~any(isnan(q_sol))
             % Asegurarse que q_sol es un vector fila 1x6
             if size(q_sol, 1) > 1; q_sol = q_sol.'; % Asegurar fila
               qB3(i,:) = q_sol;
               q_seed_B = q_sol; % q_sol ya es fila aquí
             end
        else
             warning('IK B: No se encontró solución válida en el paso %d. Repitiendo anterior.', i);
             if i>1; qB3(i,:) = qB3(i-1,:); else; qB3(i,:) = q_seed_B; end
        end
    catch ME_ikine
        warning('IK B: Error en cin_inv_Faro en el paso %d: %s. Repitiendo anterior.', i, ME_ikine.message);
        if i>1; qB3(i,:) = qB3(i-1,:); else; qB3(i,:) = q_seed_B; end
    end
end
% Calcular qd, qdd numéricamente para el segmento 3
t_seg2_vec = linspace(0, t_seg2, N2)'; % Vector tiempo para derivada
qdB3 = derivada(qB3, t_seg2_vec);
qddB3 = derivada(qdB3, t_seg2_vec);

% Segmento 4: jtraj (ContactEnd -> Retract)
q_end_seg3 = qB3(end,:); % Posición final del segmento ctraj
[qB4, qdB4, qddB4] = jtraj(q_end_seg3, q_retract.', N_touch); % Asegurar fila

% Segmento 5: jtraj (Retract -> Start)
[qB5, qdB5, qddB5] = jtraj(q_retract.', q_start, N3); % Asegurar fila

% Concatenar (quitando puntos repetidos)
qB = [qB1; qB2(2:end,:); qB3(2:end,:); qB4(2:end,:); qB5(2:end,:)];
qdB = [qdB1; qdB2(2:end,:); qdB3(2:end,:); qdB4(2:end,:); qdB5(2:end,:)];
qddB = [qddB1; qddB2(2:end,:); qddB3(2:end,:); qddB4(2:end,:); qddB5(2:end,:)];

% Calcular trayectoria cartesiana resultante
total_puntos_B = size(qB, 1);
posB = zeros(total_puntos_B, 3);
for i = 1:total_puntos_B
    T_curr = R.fkine(qB(i,:));
    posB(i,:) = T_curr.t';
end
velB = derivada(posB, t_total'); % Necesita t_total como columna
accB = derivada(velB, t_total');

%% --- 4. Animación ---
figure('Name', 'Animación Método A (Articular)');
R.plot(qA);
title('Animación Método A (Todo jtraj)');

figure('Name', 'Animación Método B (Mixto)');
R.plot(qB);
title('Animación Método B (jtraj + ctraj)');

%% --- 5. Gráficas Comparativas ---

% Asegurarse que t_total tenga la misma longitud que las trayectorias
if length(t_total) ~= size(qA, 1) || length(t_total) ~= size(qB, 1)
   warning('Discrepancia en longitud de vectores de tiempo y trayectorias. Ajustando t_total.');
   t_total_A = linspace(t_total(1), t_total(end), size(qA,1));
   t_total_B = linspace(t_total(1), t_total(end), size(qB,1));
else
   t_total_A = t_total;
   t_total_B = t_total;
end

% --- Espacio Articular ---
figure('Name', 'Comparación Articular');
% Posición
subplot(3,1,1);
plot(t_total_A, qA, '--'); hold on;
plot(t_total_B, qB, '-'); grid on;
title('Comparación Posición Articular'); ylabel('Ángulo [rad]');
legend_q = arrayfun(@(x) sprintf('q%d', x), 1:R.n, 'UniformOutput', false);
legend([strcat(legend_q, '-A'), strcat(legend_q, '-B')], 'Location', 'bestoutside');

% Velocidad
subplot(3,1,2);
plot(t_total_A, qdA, '--'); hold on;
plot(t_total_B, qdB, '-'); grid on;
title('Comparación Velocidad Articular'); ylabel('Velocidad [rad/s]');
legend([strcat(legend_q, '-A'), strcat(legend_q, '-B')], 'Location', 'bestoutside');

% Aceleración
subplot(3,1,3);
plot(t_total_A, qddA, '--'); hold on;
plot(t_total_B, qddB, '-'); grid on;
title('Comparación Aceleración Articular'); ylabel('Aceleración [rad/s^2]');
xlabel('Tiempo [s]');
legend([strcat(legend_q, '-A'), strcat(legend_q, '-B')], 'Location', 'bestoutside');

% --- Espacio Cartesiano ---
figure('Name', 'Comparación Cartesiana');
legend_xyz = {'X', 'Y', 'Z'};
% Posición
subplot(3,1,1);
plot(t_total_A, posA, '--'); hold on;
plot(t_total_B, posB, '-'); grid on;
title('Comparación Posición Cartesiana'); ylabel('Posición [m]');
legend([strcat(legend_xyz, '-A'), strcat(legend_xyz, '-B')], 'Location', 'bestoutside');

% Velocidad
subplot(3,1,2);
plot(t_total_A, velA, '--'); hold on;
plot(t_total_B, velB, '-'); grid on;
title('Comparación Velocidad Cartesiana'); ylabel('Velocidad [m/s]');
legend([strcat(legend_xyz, '-A'), strcat(legend_xyz, '-B')], 'Location', 'bestoutside');

% Aceleración
subplot(3,1,3);
plot(t_total_A, accA, '--'); hold on;
plot(t_total_B, accB, '-'); grid on;
title('Comparación Aceleración Cartesiana'); ylabel('Aceleración [m/s^2]');
xlabel('Tiempo [s]');
legend([strcat(legend_xyz, '-A'), strcat(legend_xyz, '-B')], 'Location', 'bestoutside');

% --- Gráfico Z vs X (Geometría) ---
figure('Name', 'Trayectoria Geométrica Z vs X');
plot(posA(:,1), posA(:,3), '--', 'LineWidth', 1.5, 'DisplayName', 'Método A (jtraj)'); hold on;
plot(posB(:,1), posB(:,3), '-', 'LineWidth', 1.5, 'DisplayName', 'Método B (ctraj)'); grid on;
axis equal; xlabel('X [m]'); ylabel('Z [m]');
title('Comparación Trayectoria Geométrica en Plano XZ');
legend('Location', 'best');

%% --- 6. Selección y Justificación (Inciso 5) ---
fprintf('\n--- Selección del Método (Inciso 5) ---\n');
fprintf('El método más adecuado para la aplicación de medición de rugosidad es el Método B (Mixto).\n');
fprintf('Justificación:\n');
fprintf('1. Fase de Medición (P3 a P4): Requiere que el palpador siga una LÍNEA RECTA precisa sobre la superficie y mantenga una ORIENTACIÓN CONSTANTE (45 grados). Esto SOLO se garantiza con la interpolación cartesiana (`ctraj`). El Método A (solo `jtraj`) generaría un arco, haciendo la medición incorrecta.\n');
fprintf('2. Fases de Acercamiento y Retorno (P1->P3 y P4->P6): El camino exacto no es crítico. La interpolación articular (`jtraj`) es preferible porque genera movimientos más suaves para las articulaciones del robot, reduce vibraciones y es computacionalmente menos costosa.\n');
fprintf('El Método B combina lo mejor de ambos: precisión cartesiana donde es necesaria (medición) y suavidad articular donde es posible (movimientos de transición).\n');

%% --- Función Derivada (Recreada del TP) ---
function d = derivada(vz, t)
    % Calcula la derivada numérica de las columnas de vz respecto al tiempo t
    % usando diferencias finitas de segundo orden.
    [m, n] = size(vz); % m = número de puntos, n = número de variables

    % Verificar si t es vector columna
    if size(t, 2) > 1; t = t'; end

    if m <= 2
        warning('No hay suficientes puntos (%d) para calcular derivada. Devolviendo ceros.', m);
        d = zeros(m, n);
        return;
    end
    if length(t) ~= m
        error('El vector de tiempo (longitud %d) no coincide con los datos (%d filas).', length(t), m);
    end

    dt_vec = diff(t);
    dt_mean = mean(dt_vec);
    if any(abs(dt_vec - dt_mean) > 1e-6 * abs(dt_mean))
       % warning('El paso de tiempo no es constante (std=%.2e). Usando dt promedio (%.4f).', std(dt_vec), dt_mean);
       % Si el tiempo no es constante, usamos dt variable (más preciso)
       d=zeros (m, n); % Pre-asigna memoria
       for j=1:n
           % Punto inicial: Diferencias finitas hacia adelante (orden 2)
           d(1,j) = (-3*vz(1,j) + 4*vz(2,j) - vz(3,j)) / (t(3)-t(1)); % Usa t(3)-t(1) = 2*dt si es constante
           % Puntos intermedios: Diferencias finitas centrales (orden 2)
           for i=2:m-1
               d(i,j) = (vz(i+1,j) - vz(i-1,j)) / (t(i+1)-t(i-1)); % Usa 2*dt si es constante
           end
           % Punto final: Diferencias finitas hacia atrás (orden 2)
           d(m,j) = (3*vz(m,j) - 4*vz(m-1,j) + vz(m-2,j)) / (t(m)-t(m-2)); % Usa 2*dt si es constante
       end
       return; % Salir si ya calculamos con dt variable
    end

    % Si llegamos aquí, dt es constante
    dt = dt_mean;
    if abs(dt) < eps
        warning('El paso de tiempo es casi cero (%.2e). Devolviendo ceros.', dt);
        d = zeros(m, n);
        return;
    end

    d=zeros (m, n); % Pre-asigna memoria
    for j=1:n
        % Punto inicial: Diferencias finitas hacia adelante (orden 2)
        d(1,j) = (-3*vz(1,j) + 4*vz(2,j) - vz(3,j)) / (2*dt);
        % Puntos intermedios: Diferencias finitas centrales (orden 2)
        for i=2:m-1
            d(i,j) = (vz(i+1,j) - vz(i-1,j)) / (2*dt);
        end
        % Punto final: Diferencias finitas hacia atrás (orden 2)
        d(m,j) = (3*vz(m,j) - 4*vz(m-1,j) + vz(m-2,j)) / (2*dt);
    end
end